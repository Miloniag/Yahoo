# -*- coding: utf-8 -*-
"""Time series project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RGwO_s6lx7lO2EUzsfpSGadc_q9Nsqcz
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

yahoo_df = pd.read_csv('yahoo_stock.csv')
yahoo_df.head()

yahoo_df.info()

shape = yahoo_df.shape
print(f"Shape of data is : {shape}")
print(f"Number of rows : {shape[0]}")
print(f"Number of Columns : {shape[1]}")

yahoo_df.isna().sum()

yahoo_df.describe()

fig, axs = plt.subplots(2, figsize=(8,10))
sns.histplot(data=yahoo_df, x='Close', ax=axs[0], kde=True)
axs[0].set_title('Closing price distribution')
sns.histplot(data=yahoo_df, x='Close', ax=axs[1], log_scale=True, kde=True)
axs[1].set_title('Log Scale')
plt.show()

"""There isn't much noticable differences between distribution of closing stock prices and their log transformations"""

for column in yahoo_df.columns:
    if column != 'Date':
        plt.figure(figsize=(8, 6))
        yahoo_df.plot(x='Date', y=column)
        plt.title(column)
        plt.xlabel('Date')
        plt.ylabel(column)
        plt.show()

"""The time series is following an uptrend"""

# Apply first-order differencing to the 'Close' column
yahoo_df['Close_diff'] = yahoo_df['Close'].diff()

# Plot the original and differenced 'Close' price
plt.figure(figsize=(12, 6))
plt.plot(yahoo_df['Date'], yahoo_df['Close'], label='Original Close Price')
plt.plot(yahoo_df['Date'], yahoo_df['Close_diff'], label='First-Order Differenced Close Price')
plt.xlabel('Date')
plt.ylabel('Price')
plt.title('Original and Differenced Close Prices')
plt.legend()
plt.show()

#Applying seasonal decomposition
from statsmodels.tsa.seasonal import seasonal_decompose

plt.figure(figsize=(16, 8))

result = seasonal_decompose(yahoo_df['Close'], model='multiplicative', period=365)
result.plot()
plt.xticks(rotation=90)
plt.show()

plt.figure(figsize=(10,6))
sns.histplot(yahoo_df['Close'].dropna(), bins=100, kde=True)
plt.title('Distribution of Highest stock price')
plt.show()

#Correlation Analysis
# Convert 'Date' column to datetime objects for proper handling in calculations
yahoo_df['Date'] = pd.to_datetime(yahoo_df['Date'])

# Select only numerical features for correlation analysis
numerical_features = yahoo_df.select_dtypes(include=['number'])

corr_matrix = numerical_features.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix')
plt.show()

#Stationarity
import statsmodels.tsa.stattools as tsastattools
result = tsastattools.adfuller(yahoo_df['Close'])

# Print results
print('ADF Statistic:', result[0])
print('p-value:', result[1])
print('Critical Values:')
for key, value in result[4].items():
    print(key, ':', value)

if result[1] < 0.05:
    print('Reject the null hypothesis. The series is likely to be stationary.')
else:
    print('Fail to reject the null hypothesis. The series is likely to be non-stationary.')

#ACF
import statsmodels.api as sm
plt.figure(figsize=(8, 6))
sm.graphics.tsa.plot_acf(yahoo_df['Close'], lags=20)
plt.title('ACF')
plt.xlabel('Lag')
plt.ylabel('Autocorrelation')
plt.show()

#PACF
plt.figure(figsize=(8, 6))
sm.graphics.tsa.plot_pacf(yahoo_df['Close'], lags=20)
plt.title('PACF')
plt.xlabel('Lag')
plt.ylabel('Partial Autocorrelation')
plt.show()

# ARIMA Model with specified (p, d, q) order
from statsmodels.tsa.arima.model import ARIMA # Import the ARIMA class
p = 1
d = 1
q = 1

model = ARIMA(yahoo_df['Close'], order=(p, d, q))

# Fit the model
model_fit = model.fit()

# Print model summary
print(model_fit.summary())

# Make predictions
predictions = model_fit.predict(start=len(yahoo_df) - 365, end=len(yahoo_df) - 1) # Example: predict the last 365 days

# Plot the predictions against actual values
plt.figure(figsize=(12, 6))
plt.plot(yahoo_df['Close'][-365:], label='Actual')
plt.plot(predictions, label='Predicted')
plt.legend()
plt.title('ARIMA Model Predictions')
plt.show()


# Plot residuals
residuals = pd.DataFrame(model_fit.resid)
fig, ax = plt.subplots(1,2,figsize=(15,5))
residuals.plot(title="Residuals", ax=ax[0])
residuals.plot(kind='kde', title='Density', ax=ax[1])
plt.show()

import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
# Define the (p, d, q) and (P, D, Q, s) orders for the SARIMA model
order = (1, 1, 1)
seasonal_order = (1, 1, 1, 12)  # s=12 for monthly data

# Create and fit the SARIMA model
model = SARIMAX(yahoo_df['Close'], order=order, seasonal_order=seasonal_order)
model_fit = model.fit(disp=False)

# Print the model summary
print(model_fit.summary())

# Make predictions
predictions = model_fit.predict(start=len(yahoo_df['Close']) - 30, end=len(yahoo_df['Close'])) #Example prediction

#Plot the predictions against actual values
plt.figure(figsize=(12,6))
plt.plot(yahoo_df['Close'][-30:], label='Actual')
plt.plot(predictions, label='SARIMA Predictions')
plt.legend()
plt.title('SARIMA Model Predictions')
plt.show()

# Applying time series models

import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX

#Exponential Smoothing
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from sklearn.metrics import mean_squared_error, mean_absolute_error


# Define forecast_steps: how many steps into the future to forecast
forecast_steps = 200

# Fit Exponential Smoothing model
hw_model = ExponentialSmoothing(yahoo_df['Close'], trend='add', seasonal='add', seasonal_periods=12)
hw_fit = hw_model.fit()


# Forecast using Exponential Smoothing
hw_forecast = hw_fit.forecast(steps=forecast_steps)

# Evaluate Exponential Smoothing
hw_forecast = hw_forecast
actual_values_for_comparison = yahoo_df['Close'][-forecast_steps:] # Get the last 'forecast_steps' values for comparison

hw_mse = mean_squared_error(actual_values_for_comparison, hw_forecast) # Compare with corresponding actual values
hw_mae = mean_absolute_error(actual_values_for_comparison, hw_forecast)
hw_rmse = hw_mse ** 0.5
print(f'Exponential Smoothing MSE: {hw_mse:.2f}')
print(f'Exponential Smoothing MAE: {hw_mae:.2f}')
print(f'Exponential Smoothing RMSE: {hw_rmse:.2f}')


#Plot Exponential Smoothing Forecast
plt.figure(figsize=(8, 6))
plt.plot(yahoo_df['Close'], label='Actual', color='green')

# For plotting, you might want to shift the forecast to align with the actual data
plt.plot(yahoo_df.index[-forecast_steps:], hw_forecast, label='Exponential Smoothing Forecast') # Shift for plotting
plt.title('Exponential Smoothing Forecasted Values')
plt.xlabel('Date')
plt.ylabel('Closing stock price')
plt.legend()
plt.show()

# Detrending
# Using a rolling mean to detrend the data
yahoo_df['Close_Rolling_Mean'] = yahoo_df['Close'].rolling(window=365).mean()
yahoo_df['Close_Detrended'] = yahoo_df['Close'] - yahoo_df['Close_Rolling_Mean']

# Deseasonalizing
yahoo_df['Close_Seasonal'] = result[2]

yahoo_df['Close_Deseasonalized'] = yahoo_df['Close'] / yahoo_df['Close_Seasonal']


# Plotting detrended and deseasonalized data
plt.figure(figsize=(12, 6))
plt.plot(yahoo_df['Close_Detrended'], label='Detrended')
plt.plot(yahoo_df['Close_Deseasonalized'], label='Deseasonalized')
plt.legend()
plt.title("Detrended and Deseasonalized Time Series")
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose
import statsmodels.api as sm
import statsmodels.tsa.stattools as tsastattools
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error, mean_absolute_error
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# AIC and BIC for ARIMA Model
# Trying different (p, d, q) orders and comparing their AIC/BIC values
p_values = range(0, 3)
d_values = range(0, 2)
q_values = range(0, 3)

best_aic = float('inf')
best_bic = float('inf')
best_order = None


for p in p_values:
    for d in d_values:
      for q in q_values:
        try:
          model = ARIMA(yahoo_df['Close'], order=(p,d,q))
          model_fit = model.fit()
          aic = model_fit.aic
          bic = model_fit.bic

          print(f"ARIMA({p},{d},{q}): AIC={aic:.2f}, BIC={bic:.2f}")

          if aic < best_aic:
              best_aic = aic
              best_bic = bic
              best_order = (p,d,q)

        except Exception as e:
          print(f"Error fitting ARIMA({p},{d},{q}):",e)
          continue


print(f"\nBest ARIMA Order (based on AIC): {best_order}, AIC: {best_aic:.2f}, BIC: {best_bic:.2f}")

# Now you can refit the ARIMA model using the best_order:
best_arima_model = ARIMA(yahoo_df['Close'], order=best_order)
best_arima_fit = best_arima_model.fit()
print(best_arima_fit.summary())

import statsmodels.api as sm
import matplotlib.pyplot as plt
# ACF and PACF of the differenced 'Close' price
plt.figure(figsize=(8, 6))
sm.graphics.tsa.plot_acf(yahoo_df['Close_diff'].dropna(), lags=20)  # Use dropna() to handle NaN values
plt.title('ACF of Differenced Close Price')
plt.xlabel('Lag')
plt.ylabel('Autocorrelation')
plt.show()

plt.figure(figsize=(8, 6))
sm.graphics.tsa.plot_pacf(yahoo_df['Close_diff'].dropna(), lags=20)  # Use dropna() to handle NaN values
plt.title('PACF of Differenced Close Price')
plt.xlabel('Lag')
plt.ylabel('Partial Autocorrelation')
plt.show()

import warnings
warnings.filterwarnings('ignore')
# AIC and BIC for SARIMA Model
# Trying different (p, d, q) and (P, D, Q, s) orders and comparing their AIC/BIC values

p_values = range(0, 2)
d_values = range(0, 2)
q_values = range(0, 2)
P_values = range(0, 2)
D_values = range(0, 2)
Q_values = range(0, 2)
s_values = [12]

best_aic = float('inf')
best_bic = float('inf')
best_order = None
best_seasonal_order = None

for p in p_values:
    for d in d_values:
        for q in q_values:
            for P in P_values:
                for D in D_values:
                    for Q in Q_values:
                        for s in s_values:
                            try:
                                order = (p, d, q)
                                seasonal_order = (P, D, Q, s)
                                model = SARIMAX(yahoo_df['Close'], order=order, seasonal_order=seasonal_order)
                                model_fit = model.fit(disp=False)
                                aic = model_fit.aic
                                bic = model_fit.bic

                                print(f"SARIMA({p},{d},{q})({P},{D},{Q},{s}): AIC={aic:.2f}, BIC={bic:.2f}")

                                if aic < best_aic:
                                    best_aic = aic
                                    best_bic = bic
                                    best_order = order
                                    best_seasonal_order = seasonal_order

                            except Exception as e:
                                print(f"Error fitting SARIMA({p},{d},{q})({P},{D},{Q},{s}):", e)
                                continue

print(f"\nBest SARIMA Order (based on AIC): {best_order}x{best_seasonal_order}, AIC: {best_aic:.2f}, BIC: {best_bic:.2f}")

# Now you can refit the SARIMA model using the best_order and best_seasonal_order:
best_sarima_model = SARIMAX(yahoo_df['Close'], order=best_order, seasonal_order=best_seasonal_order)
best_sarima_fit = best_sarima_model.fit(disp=False)
print(best_sarima_fit.summary())